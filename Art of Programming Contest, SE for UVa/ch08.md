# 第八章 排序

* 問題定義
  * 輸入：一串 N 個數字的序列 (a1, a2, ..., aN)
  * 輸出：輸入的一種排列方式  (a1', a2', ..., aN') 使得 a1' <= a2' <= ... <= aN'

* 要先考慮的事項
  1. 輸入序列的長度
     * 有時記憶體會放不下整串序列，必須做「外部排序 (external sort)」，但比賽的題目幾乎不會有這樣的情形
  2. stability
     * 假設 a 和 b 在排序比較時會當成一樣的大小，一個排序演算法若能保證 a 和 b 排序前和排序後的先後關係不會顛倒，即稱此排序演算法為 stable
  3. key sorting
     * 要被排序的資料每一筆都很大，移動時會花上許多成本

* 基於比較關係的排序演算法

  輸入中的資料，兩兩互做比較，所以會較為關注比較的次數和每次比較所需的時間
  
  * 氣泡排序法 (Bubble Sort)
     * 時間：O(n ^ 2)
     * 空間：輸入的大小
     * 較好實作
     * 氣泡排序法的題目們
         * 299 - Train Swapping
         * 612 - DNA Sorting
         * 10327 - Flip Sort
  * 快速排序法 (Quick Sort)
     * 時間：O(n log n)
         * 分兩邊：O(n)
         * 為左邊排序：O(log n)
         * 為右邊排序：O(log n)
     * 空間：輸入的大小
     * 使用分而治之法，較為複雜
     * stdlib.h 的 qsort()
         1. 比較兩整數：用減的（註：小心溢位）
         2. 比較兩字串：用 strcmp()
         3. 比較兩浮點數：不可以用減的！

* 多重條件的排序
  * 例：排序通訊錄中的生日（比較順序：月 → 日 → 年）
  * 使用 stable sort 或是 把比較條件展開
  * 「多重條件的排序」的題目
     * 10194 - Football (aka Soccer)

* 線性時間複雜度的排序
  * 基於比較關係的排序演算法 最快只能到 O(n log n) → 使用「決策樹 (decision tree)」證明
  * 計數排序法 (Counting Sort)
     * 假設已知輸入數字的範圍，先使用陣列計算每個數字出現的次數，再依照陣列內容輸出，不須任何兩兩比較
     * 時間：O(n + k)，n 是輸入序列的長度，k 是數字的範圍大小
  * Radix Sort
     * 假設輸入皆為 d 位數的數字，先依照 LSD → MSD，使用 stable sort
     * 時間：O( d * (stable sort 的時間) )
