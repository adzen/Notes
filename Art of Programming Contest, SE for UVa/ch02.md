# 第二章 比賽的準備

* 組隊
  * 雖然每個隊員的能力很重要，但善用隊員的長處，為整個隊得到更好的成績更重要
  * 一些篩選依據：
     * 熟悉演算法，並能為比賽的每一題題目想出適合的演算法
     * 很會寫程式，可以很快、正確地把解題想法實作成程式碼
     * 有策略地協調隊員的工作，善用隊員的能力

* 演算法
  > 用了錯誤的演算法就像用螺絲起子切牛排一樣
  * 必須知道一堆有名的演算法，並能為題目選出適合的解法（較直觀的題目），或是哪些演算法的變形或組合（較難的題目）
  * 正確的演算法
     1. 能夠結束 → TLE、MLE、OLE
     2. 有正確的輸出 → 有名的 WA
     3. 要有效率 → TLE

* 常見的題目類型
  > 在程設比賽中，只有三種題目：我沒看過／我看過，但我沒寫過或答對過／我答對過
  * 數學、動態規劃 (DP)、圖論 (Graph)、排序、搜尋、模擬、字串處理、計算幾何、AdHoc
  * Ad Hoc 題目沒有標準的演算法，會使題目更加有趣（更簡單 或 更難），因為每一題都是個新挑戰
  
* 分析你的演算法
  * 根據題目的輸入範圍限制，我的演算法能否正確地算出答案，並能在時間限制內執行結束？
  * **腦力激盪所有可能並可行的演算法，然後從中挑選最笨的！**
  
* 學習演算法
  * 證明演算法的正確性（特別是貪婪演算法）
  * 時間/空間複雜度
  * 分析有遞迴關係的演算法 → Master Theorem
  * Amortized analysis
  * Output-sensitive analysis
  
* 複雜度關係
  * 常數 < log n < n < n log n < n^2 < n^3 < 2^n < n!
  * 在比賽中，大部分題目使用 O(n log n) 的演算法仍是足夠的

* 測試的藝術
  * 根據比賽的類型，如果你部分答對題目，你可以（或不可以）得到部分分數
     * ACM ICPC → 不會給部分分數。每一題只有 Accepted 或 Not Accepted 的分別
     * IOI → 答對部分測資，可以得到部分分數
  * 一些教練在練習時會請同學設計測資「攻破」其他同學的程式
  * 設計測資的一些準則：
     1. 題目的範例輸入/輸出
     2. 邊界條件
     3. 多筆 case 輸入的題目，試著連續使用兩個相同的 case（防止變數忘記初始化）
     4. 逐漸增加輸入的規模
     5. 一些陷阱的測資（要根據題目）
     6. 不要假設題目的輸入都有良好的格式（試著加一些換行或空白）
     7. 隨機產生的測資

* 產生「勝利的」答案
  * 讀過 *所有的* 題目，在還沒找到最簡單的題目前，不要隨便開工
  * 把題目依照難度排序

* 實作時的要點
  * 要先「確定」演算法才開始動手寫
  * 撰寫註解
  * 測試並除錯每一個小功能

* 時間管理 和 災害控制
  * 預先想好比賽可能發生的任何狀況
  * 忘卻過去，要專注當下和未來

* 比賽的小技巧
  1. 不要忘了暴力解法
  2. KISS: Keep it simple, and stupid!!
  3. 注意題目敘述中的限制
  4. 記憶體很大不用錢，要會用空間換取時間
  5. 不要刪掉除錯用的列印功能，註解掉即可
  6. 該最佳化的時候才最佳化
  7. 保留所有可行的版本
  8. 先寫註解再填程式碼
  9. 盡量避免指標、動態記憶體
  10. 盡量避免浮點數運算，若要用則記得加上誤差
  11. 記錄每場比賽的表現並檢討

* 出題者是邪惡的
  * 我們會把簡單的題目藏起來，希望你投入較難的問題
  * 簡單的題目我們會寫得讓它看起來很難，反之亦然
  * 不要忘了會場中有幾十隊都在做同樣的題目，如果一堆人都在寫（或答對）題目 G，則你應該先嘗試題目 G 才對

