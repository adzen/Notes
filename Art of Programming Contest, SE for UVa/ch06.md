# 第六章 暴力解法

最基本的演算法。使用了電腦計算速度很快的特性。

如果可以達成計算時間、記憶體限制的話，這應為最先嘗試的解題方法。

* 例題：Party Lamps（題目內容請見原書）
  * 針對每次按鍵，嘗試四種可能 → 4^10000（約為 10^6020）
  * 發現按鍵的順序不影響結果 → 10000^4（約為 10^16）
  * 發現兩次按鍵相當於沒有按，於是四個開關只要嘗試開或關即可 → 2^4 = 16

* 例題：The Clocks（題目內容請見原書）
  * 列舉出一步、兩步、......的結果，嘗試找出答案 → 9^k（假設需要 k 步才會變成答案）
  * 發現移動的順序不影響結果 → k^9
  * 發現同一種動作使用四次相當於沒有使用此動作 → 4^9 = 262144
  
嘗試找出題目的特性，減小搜尋範圍，如此暴力解法也能勝任比賽的題目。

* 遞迴 (Recursion)
  * 回溯法 (backtracking)
  * base case 或終止條件必須正確，否則會 stack overflow
  * 大多數 CS 的問題使用了遞迴，而且部分問題遞迴得很自然(?)
  * 一些問題可用遞迴和 iterative 解決時，則使用 iterative 的版本，執行速度會比較快，也能節省記憶體。
     * 例如：階乘、費式數列、......
  * 然而也有些問題只能用遞迴解法、遞迴解法反而比較有效率、iterative 解法很難想
     * 例如：河內塔、搜尋問題 (DFS, BFS)、......
     
* 遞迴的種類
  * Linear recursion：複雜度呈線性成長
  * multiple branch (Tree) recursion：複雜度成長得很快可怕，不適合解決大問題
  * 一些編譯器可以把 tail recursion 轉換成 iterative 的版本，增加執行效率
  
* 如何思考遞迴：國中教過的數學歸納法 (mathematical induction)
  * 先想 base case → 假設 f(n-1) 的答案是對的，要如何產生 f(n) 的答案？
  
* 使用遞迴時要思考的事項
  1. 大問題如何分解成小問題？
  2. 每次的遞迴會如何減少問題規模？
  3. base case？
  4. 逐步減少問題規模時，我可以達到 base case 嗎？
  
* 分而治之法 (Divide and Conquer)
  * 例子：Quick Sort, Merge Sort, Binary Search.
  * 三個主要步驟：
     1. 把問題分解呈子問題
     2. 找出子問題的答案（通常使用遞迴）
     3. 使用子問題的答案拼湊出原問題的答案
     
DC(P) {
  if small(P) then
    return Solve(P);
  else {
    divide P into smaller instances P1,...,Pk, k>1;
    Apply DC to each of these subproblems;
    return combine(DC(P1),...,DC(Pk));
  }
}

* 二元搜尋法的先決條件：要先排序

* 優化你的演算法
  * 產生 vs. 篩選
     * 例子：八皇后問題
     * 產生所有可能，篩選出符合題目限制的組合
     * 如何優化「產生」法？如何優化「篩選」法？
  * 預先計算
     * 把一些已知問題的答案存起來，用空間換時間
     * 例子：質數表
  * 拆解問題
     * 比賽用到的基本演算法並不多，要如何拆解困難的問題？
  * 找出對稱性 (Symmetries)
     * 使用對稱性減少計算時間
     * 例如：兩點的直線距離，從任一點出發都是一樣的
     * 但小心有時會產生出重複的答案。應視原問題決定要不要剔除
  * 正攻 vs. 反攻
     * 很多比賽的問題常常需要反攻法
     * 例如：把輸入顛倒順序 或 用特殊的順序處理輸入
