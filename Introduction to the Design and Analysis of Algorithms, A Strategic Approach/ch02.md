# 第二章 演算法的複雜度 和 題度難度的下限

1. 如何測量一個演算法的好壞？
2. 如何測量一個問題的難度？
3. 對於某個問題，我們怎麼知道這個演算法是最佳的？有沒有更好的演算法？

## 2.1 演算法的時間複雜度

* 好的演算法
  * 使用較短的執行時間
  * 使用較少的記憶體
* 如果不特地說明，本書主要看的是時間因素

* 寫個程式，看它跑多快(?)
  * 程式設計師的功力
  * 程式語言
  * 作業系統
  * 編譯器
  
* 比較排序演算法時，通常計算比較的次數
  * 然後有時移動資料，會比比較資料還要更花成本，這時便計算移動資料的次數
  
* 時間的成本會跟題目的規模 n 有關
  * (n^3 + n) → n^3
  
> 定義：f(n) = O(g(n)) ←→ 存在兩正數 c, n0 使得 |f(n)| <= c|g(n)| 對於所有 n >= n0 的情況 

f(n) = n^3 + n = (1 + 1/n^2) n^3 <= 2n^3 for n >= 1

* 時間複雜度的迷思：
  * O(n) 一定跑得比 O(n^3) 還要快？
     * 還要考慮每一個「步驟」所花的時間
  * O(n) 和 O(n) 跑的一樣快？
     * 還需要考慮常數 c 的大小
     
* 如果兩個演算法都能被硬體化，則時間複雜度就顯得重要。

* 表格 2-1：時間複雜度和題目規模的關係
  1. 找到複雜度較低的演算法是很有用的
  2. polynomial algorithms vs. exponential algorithms
     * 兩者差異很大，但有很多演算法其實是 exponential 但沒有什麼 polynomial 的可以改善之
     
* 本節並沒考慮輸入資料的因素，下節會考慮

## 2.2 演算法最佳、平均、最差情況的分析

